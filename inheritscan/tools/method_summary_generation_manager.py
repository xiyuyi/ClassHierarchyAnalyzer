import copy
from collections import defaultdict
from typing import List, Tuple

from inheritscan.agents.microchains.chains.chunks2method import \
    get_chunks2method_chain
from inheritscan.core.datatypes import ClassInfo
from inheritscan.storage.summary_mng import SummaryManager


class MethodSummary:
    # given a list of (modules, classes, method):
    # generate the summaries for them using a minichain.
    # update the summarries in method at the class level.
    # organize the result data with defined datatypes and save in designation place.

    def __init__(
        self,
        summary_manager: SummaryManager,
        tasks: List[Tuple[str, str, str]],
    ):
        """
        tasks: [(mod, class_name, method name)]
        """
        # keep tasks the same format across ClassSummary, MethodSummary and ChunkSummary classes.

        self.summary_archive_manager = summary_manager
        self.tasks = tasks
        self.aggregated_tasks = defaultdict(list)
        self.aggregated_method_chunk_summaries = defaultdict(str)
        self.aggregated_method_summaries = defaultdict(str)
        self.aggregated_classinfo_queue = []
        self.method_summary_chain_name = summary_manager.summary_chain_name
        self.method_summary_chain = get_chunks2method_chain(
            self.method_summary_chain_name
        )
        self._aggretate_tasks()
        self._aggretate_methods()
        self.invoke_queue = [k for k in self.aggregated_method_chunk_summaries]

    def _aggretate_tasks(self):
        "aggregate list of tasks into {(mod, class_name): list of methods}"
        for mod, class_name, method_name in self.tasks:
            self.aggregated_tasks[(mod, class_name)].append(method_name)

    def _aggretate_methods(self):
        "aggregate list of tasks into {(mod, class_name, method): aggregated_chunk_summaries}"

        # code_base_dir = self.summary_manager.code_base_dir
        for mod, class_name in self.aggregated_tasks:
            class_info = self.summary_archive_manager.load_classinfo(
                mod, class_name
            )
            method_names = self.aggregated_tasks[mod, class_name]
            for method_name in method_names:
                method_info = class_info.methods[method_name]
                n_snippets = len(method_info.snippets)
                aggregated_summary = ""
                for snippet_index in range(n_snippets):
                    snippet_info = method_info.snippets[
                        f"chunk_{snippet_index}"
                    ]
                    # TODO #24 should be something like the get summary for 1 chunk method.
                    summary = snippet_info.summary
                    aggregated_summary += f"\n\nchunk_{snippet_index}"
                    aggregated_summary += "\n"
                    aggregated_summary += summary
                self.aggregated_method_chunk_summaries[
                    (mod, class_name, method_name)
                ] = aggregated_summary

            # prepare placeholders for the aggregated summaires for each method ( every method)
            self.aggregated_method_summaries[(mod, class_name)] = {
                method_name: None for method_name in method_names
            }

    def get_summaries_for_all_methods_and_classes(self):
        self.method_updated_flag = False
        while self.invoke_queue:
            self._get_summary_for_1_method()

        self.aggregated_classinfo_queue = list(
            self.aggregated_method_summaries.keys()
        )

    def _get_summary_for_1_method(self):
        # TODO #24 load the method summary through the summary manager
        # if the summary generated by the currently selected model is there, assing it.
        # otherwise, generate it.
        # the method chunk summaries should be achieved through
        #   ChunkSummary._get_summary_for_1_method method.
        # it should be in the aggregate logic
        mod, class_name, method_name = self.invoke_queue.pop()
        summary = self.summary_archive_manager.load_method_summary(
            mod, class_name, method_name
        )
        if summary is None:
            print(
                f"Generate method summary {mod}, {class_name}, {method_name}"
            )
            aggregated_summary = self.aggregated_method_chunk_summaries[
                (mod, class_name, method_name)
            ]
            response = self.method_summary_chain.invoke(aggregated_summary)
            summary = response["method_summary"]
            self.method_updated_flag = True

        self.aggregated_method_summaries[(mod, class_name)][
            method_name
        ] = summary

    def update_all_classinfo(self):
        if self.method_updated_flag:
            while self.aggregated_classinfo_queue:
                self._update_1_classinfo()

    def _update_1_classinfo(self):
        """
        Get one (mod, class name) info, then update the corresponding classinfo to file
        Only pay attention to the "summary" field for MethodInfo objects.
        as long as this method is triggered, the class summary has to be resetted to None.
        """

        mod, class_name = self.aggregated_classinfo_queue.pop()

        # get class_info
        class_info: ClassInfo = self.summary_archive_manager.load_classinfo(
            module_path=mod, class_name=class_name
        )
        class_info_old = copy.deepcopy(class_info)

        # update the data fields in class_info
        method_summaries = self.aggregated_method_summaries[(mod, class_name)]
        class_info = self.summary_archive_manager.update_methods_summaries(
            class_info, method_summaries
        )
        class_info.summary = None

        updated_class_info = self.summary_archive_manager.update_classinfo(
            class_info_old, class_info
        )

        self.summary_archive_manager.save_classinfo(updated_class_info)
